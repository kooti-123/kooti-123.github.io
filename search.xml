<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基础回溯算法</title>
    <url>/2025/10/25/%E5%9F%BA%E7%A1%80%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式，回溯是递归的副产品，只要有递归就会有回溯。</p>
<span id="more"></span>

<p>回溯算法并不是什么高效的算法，实质上就是不断穷举出所有的可能性，其中可以加一些剪枝操作以提高效率，但本质上还是穷举，所以并不会快到那哪里去</p>
<hr>
<p><strong>回溯法解决的问题</strong></p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p>回溯法的问题都可以抽象为树形结构来解决</p>
<hr>
<p><strong>回溯法的模板分为三部分：</strong></p>
<p>1是函数传递的参数和返回值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTracking</span><span class="params">(参数)</span></span></span><br></pre></td></tr></table></figure>

<p>通常没有返回值，而在写回溯函数的时候，参数不需要那么快定下来，可以在写的过程中知道具体逻辑，然后要调用哪些参数就填写哪些参数</p>
<p>2是回溯的终止条件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历树形结构一定要有终止条件</p>
<p>3是回溯搜索的遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环条件)&#123;</span><br><span class="line">	存放节点;</span><br><span class="line">	<span class="built_in">backTracking</span>(传递的参数);<span class="comment">//递归调用</span></span><br><span class="line">	回溯，撤销节点;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下就是回溯搜索的完整模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(循环条件)&#123;</span><br><span class="line">        存放节点;</span><br><span class="line">        <span class="built_in">backTracking</span>(传递的参数);<span class="comment">//递归调用</span></span><br><span class="line">        回溯，撤销节点;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>下面举leetcode的几个题目为例</strong></p>
<p>77，216，17</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Code</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>入门动态规划(Dynamic Programming)问题——leetcode 70(爬楼梯)和746(最小花费爬楼梯)的简单dp问题</title>
    <url>/2025/10/21/%E5%85%A5%E9%97%A8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92(Dynamic%20Programming)%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94leetcode%2070(%E7%88%AC%E6%A5%BC%E6%A2%AF)%E5%92%8C746(%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF)%E7%9A%84%E7%AE%80%E5%8D%95dp%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>首先动态规划和贪心的区别：贪心的核心就是从局部最优推到整体最优，和上一个状态没有关系，而动态规划顾名思义是动态的问题，比如经典的背包问题，每次装入时要考虑到背包的容量，而容量的大小通常由上一个装入背包的大小影响，所以贪心解决不了动态规划</p>
<span id="more"></span>

<!-- more -->

<!-- more -->

<!-- more -->

<p>在动态规划问题上，我们要先考虑好5步：</p>
<p>1：确定dp数组及下标含义</p>
<p>2：确定递推公式</p>
<p>3：dp数组的初始化</p>
<p>4：数组的遍历顺序</p>
<p>5：举例推导dp数组</p>
<p>以leetcode70为例：</p>
<p>1，确定dp数组：dp[i]数组确定为到达i阶有多少种方案;</p>
<p>2，递推公式：我们到达第i阶是怎么到达的，只有两种方案，一个是从i-1走1步，另一个是从i-2走2步，所以到达第i阶就是这两个的总和相加，而到i-1的方案总数为dp[i-1],同理到达i-2的数量为dp[i-2]；所以推导出递推公式为dp[i]&#x3D;dp[i-1]+dp[i-2];</p>
<p>3，初始化：dp[1]&#x3D;1,dp[2]&#x3D;2;</p>
<p>4，数组遍历顺序：因为是由前两个的阶梯数推导出后第i个阶梯的方案，则从前往后遍历；</p>
<p>5，可以自己举例子 (n&#x3D;3有三种)</p>
<p>从而我们便可以得出代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>leetcode746：</p>
<p>1，确定dp数组：dp[i]数组确定为到达i阶需要花费的总的钱数;</p>
<p>2，数组遍历顺序：这里我写这道题时先考虑的遍历顺序，由题可知，dp[n]&#x3D;0,也就是到达屋顶，所以我进行反向遍历，那么最后的第1层和第0层只要比较两个的最小值就可以知道从哪个点出发花费最小；</p>
<p>3，递推公式：爬到第i层我们的最小花费怎么求？同70我们也可以知道i的花费也由i-1和i-2决定，毕竟dp[i-1],dp[i-2]分别是到达第i-1层的最小花费和到达第i-2层的最小花费，所以我们找到其中的最小花费，则dp[i]&#x3D;cost[i]+min(dp[i-1],dp[i-2]);</p>
<p>4，初始化：dp[n]&#x3D;0,dp[n-1]&#x3D;cost[n-1];</p>
<p>5，举例子：略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[cost.<span class="built_in">size</span>()] = <span class="number">0</span>;</span><br><span class="line">        dp[cost.<span class="built_in">size</span>() - <span class="number">1</span>] = cost[cost.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = cost.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i] = cost[i] + <span class="built_in">min</span>(dp[i + <span class="number">1</span>], dp[i + <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不过正向和方向遍历也没什么区别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 默认第一步都是不花费体力的</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参考思路来自《代码随想录》</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>Code</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
